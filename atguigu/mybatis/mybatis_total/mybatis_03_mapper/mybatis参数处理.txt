单个参数:mybatis不会做特殊处理(可以任何值)
    #{参数名}:取出参数值

多个参数:mybatis会做特殊处理
    多个参数会被封装成一个map，
    key:param1...paramN 或者参数的索引也可以
    value:传入的参数的值
    #{}就是从map中获取指定的key的值
        异常：
         org.apache.ibatis.binding.BindingException:
         Parameter 'id' not found.
         Available parameters are [0, 1, param1, param2]
        操作：
            方法：Employee getEmpByIdAndLastName(Integer id,String lastName);
            取值：#{id},#{lastName}

命名参数:明确指定封装时参数值map的key
     多个参数会被封装成一个map，
        key:使用@Param注解指定的值
        value:参数值
     #{指定的key}取出对应的值

POJO:
如果多个参数正好是我们业务逻辑的数据类型，我们就可以直接传入pojo
    #{属性名}:取出传入的pojo的属性值
Map
如果多个参数不是我们业务逻辑的数据类型，没有对应的pojo，不经常使用，为了方便我们可以直接传入map
    #{key}:取出map中对应的值

如果多个参数不是业务模型中的数据，但是经常要使用，推荐编写一个TO(Transfer Object)数据传输对象
Page{
    int index;
    int size;
}
============================================思考==================================================================
public Employee getEmp(@Param("id") Integer id,String lastName);
    取值:  id=====>#{id/param1}
           lastName=====>#{param2}

public Employee getEmp(Integer id,@Param("e") Employee emp);
    取值: id===>#{param1}   lastName====>#{param2.lastName/e.lastName}

###特别注意，如果是Collection(List、Set)类型或者是数组也会特殊处理。也是把传入的传入的list或者数组封装在map中。
        key:Collection(collection),如果是List还可以使用(list)
            数组(array)
public Employee getEmpById(List<Integer> ids);
    取值:取出第一个id的值:#{list[0]}
=======================================结合源码看mybatis怎么处理==================================================================
(@Param("id") Integer id, @Param("lastName")String lastName)
 ParamNameResolver解析参数封装map的；
// 1、names:{0:id,1=lastName}  构造器的时候就确定好了
     确定流程：
      1、获取每个标了param注解的参数的值:id,lastName ;赋值给name
      2、每次解析一个参数给map中保存信息，（key:参数索引,value: name的值）
            name的值:标注了param注解：注解的值
                    没有标注:
                        1.全局配置:useActualParamName(jdk1.8),name=参数名
                        2.name=map.size();相当于当前元素的索引
args【1,"zhangsan"】:

 public Object getNamedParams(Object[] args) {
    final int paramCount = names.size();
    //1.参数为null直接返回
    if (args == null || paramCount == 0) {
      return null;
    //2.如果只有一个元素并且没有@param注解:args[0]  单个参数直接返回
    } else if (!hasParamAnnotation && paramCount == 1) {
      return args[names.firstKey()];
    //3.多个元素或者有@param标注
    } else {
      final Map<String, Object> param = new ParamMap<Object>();
      int i = 0;
      //4.遍历names集合{0:id,1=lastName}
      for (Map.Entry<Integer, String> entry : names.entrySet()) {
        //names集合的value作为key；names集合的key有作为取值的参考args[0] args【1,"zhangsan"】
        //{id:args[0](1),lastName:args[1]("zhangsan")}
        param.put(entry.getValue(), args[entry.getKey()]);
        // add generic param names (param1, param2, ...)
        //额外地将每一个参数保存到map中，使用新的key：param1....paramN
        //效果#{指定的key} 或者#{paramN}
        final String genericParamName = GENERIC_NAME_PREFIX + String.valueOf(i + 1);
        // ensure not to overwrite parameter named with @Param
        if (!names.containsValue(genericParamName)) {
          param.put(genericParamName, args[entry.getKey()]);
        }
        i++;
      }
      return param;
    }
  }
===================================参数值的获取======================================================
#{}:可以获取map中的值或者pojo对象属性的值
${}:可以获取map中的值或者pojo对象属性的值
    区别:
        #{}:是以预编译的形式，将参数设置到sql语句中。PrepareStatement； 防止sql注入
        ${}:取出的值直接拼装在sql语句中;会有安全问题
        大多情况下取参数的值,我们取参数的值都应该去使用#{}:

        原生jdbc不支持占位符的地方我们就可以使用${}进行取值
            比如分表、排序等：按照年份分表拆分
                select * from ${year}_salary where xxx=#{}
                select * from tbl_employee order by ${f_name} ${order}(desc/asc)


#{}:更丰富的用法:
    规定的参数的规则
    javaType、jdbcType、mode(存储过程)、numericScale、
    resultMap、typeHandler、jdbcTypeName、expression(未来准备支持的功能)

    jdbcType通常需要在某种特定的条件下被设置;
        在数据为null的时候，有些数据库不能识别mybatis对null的默认处理，比如Oracle(报错)。
        JdbcType OTHER:无效的类型，因为mybatis对所有的null都映射的是原生Jdbc的OTHER,Oracle不能正确识别
    由于全局配置中jdbcTypeForNull=OTHER  Oracle不支持
        1、#{email,jdbcType=NULL}
        2、jdbcTypeForNull=NULL
          <setting name="jdbcTypeForNull" value="NULL"/>
